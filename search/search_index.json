{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Personal documentation","text":""},{"location":"blog/","title":"Blog","text":"<p>This is a blog. For easy navigation, click on the Categories button on the left side of the navigation and click on the appropriate tag (e.g. click on the DFTB+ tag to see only posts related the DFTB+ software). Alternatively, use the search bar on the top right to look up specific words and navigate through all blog entries.</p>"},{"location":"dftbp/geometry-optimization/","title":"Geometry optimizations","text":"<p>With single-point calculations covered and the xTB Hamiltonian explained, there is only one more step needed to relax structures: moving the atoms around. Luckily, much like any other quantum calculation method, DFTB+ comes with a variety of engines to  optimize structures. In this section, I will explore the options available during  the relaxation. </p> <p>As a note, DFTB+ contains some drivers meant for structure relaxations which are  deprecated, and as such I will not mention them. To be more precise, this tutorial only covers the <code>GeometryOptimization</code> driver.</p>"},{"location":"dftbp/geometry-optimization/#optimizing-a-molecule","title":"Optimizing a molecule","text":"<p>As established before, the best way to learn what can be done in DFTB+ is by performing a basic calculation and then checking the resulting dftb_pin.hsd.  Geometry optimizations are no different, and to perform one you can recycle the  single-point input file from before and set the <code>Driver</code> to <code>GeometryOptimization</code>, which results in:</p> dftb_in.hsd<pre><code>Geometry = GenFormat {\n    &lt;&lt;&lt; \"H2O.gen\"\n}\n\nDriver = GeometryOptimization { }\n\nHamiltonian = xTB {\n    Method = \"GFN1-xTB\"\n}\n</code></pre> <p>That is all! Start the simulation as before and let's check the results.</p>"},{"location":"dftbp/geometry-optimization/#analyzing-the-output","title":"Analyzing the output","text":"<p>The first thing you may notice is that the geometry optimization produced the same files as the single-point calculation from before, except for the newly created geo_end.xyz and geo_end.gen files. Having a quick look at them, they contain the same geometries but using different formats. In addition to that, the .xyz file has a forth column representing the charges of the atoms.</p> geo_end.gengeo_end.xyz <pre><code>3  C\nO H\n1  1   -0.2186009291E-16   -0.7125311670E+00    0.5521821461E-16\n2  2   -0.1108690679E-15   -0.1436844645E+00    0.7710042456E+00\n3  2    0.1327291608E-15   -0.1436844645E+00   -0.7710042456E+00\n</code></pre> <pre><code>3\nGeometry Step: 9\nO     -0.00000000     -0.71253117      0.00000000      6.67118505\nH     -0.00000000     -0.14368446      0.77100425      0.66440747\nH      0.00000000     -0.14368446     -0.77100425      0.66440747\n</code></pre> <p>These two geometries turn out to be the relaxed structure, and all other output files correspond to these exact geometries. As mentioned before, except for dftb.out,  output files do not keep track of properties as the simulation progresses, but only display the properties of the last computed cycle. On the other hand, dftb.out now shows information about each optimization step, such as an overview of the  SCC procedure and energetic information for the converged charges. However, you will notice that the geometries used for each step are not saved by default, so there is  no way to know what happened during the relaxation.</p> <p>Having a look at the results, we can see from band.out that the HOMO-LUMO gap of the water molecule went from the previously computed 6.7 eV to 9.3 eV, which is considerably different from the literature value. Meanwhile, according to  detailed.out, the dipole moment went down from 3.88 Debye to 2.77 Debye, which  is closer to experimental data. </p>"},{"location":"dftbp/geometry-optimization/#possible-optimization-settings","title":"Possible optimization settings","text":"<p>The dftb_pin.hsd file can give us a better clue of what is actually going on  during the optimization. I will go through the settings one by one, but as before more details about each entry can be found in the DFTB+ manual, more specifically in Section 2.3.1.</p> <pre><code>Driver = GeometryOptimization {\n  Optimiser = Rational {\n    DiagLimit = 1.0000000000000000E-002\n  }\n  LatticeOpt = No\n  MovedAtoms = \"1:-1\"\n  Convergence = {\n    Energy = 1.7976931348623157E+308\n    GradNorm = 1.7976931348623157E+308\n    GradElem = 1.0000000000000000E-004\n    DispNorm = 1.7976931348623157E+308\n    DispElem = 1.7976931348623157E+308\n  }\n  MaxSteps = 60\n  OutputPrefix = \"geo_end\"\n  AppendGeometries = No\n}\n</code></pre> <p>The <code>GeometryOptimization</code> driver starts off with setting the <code>Optimiser</code>, which is  set to <code>Rational</code> by default. In total, there are four optimizers available:</p> <ul> <li><code>Rational</code>, which is meant to provide stability and accuracy, but scales  quadratically with the number of variables optimized;</li> <li><code>FIRE</code>, which is meant to provide speed as it scales linearly with the number of variables optimized;</li> <li><code>LBFGS</code>, which is also meant to be fast (also linear);</li> <li><code>SteepestDescent</code>.</li> </ul> <p>While there is no answer to the question \"Which optimizer should I use?\", there are some good practices that you can always apply:</p> <ol> <li>Always try the linear optimizers (<code>FIRE</code> and <code>LBFGS</code>) before settling to  <code>Rational</code>, as they can provide a significant speed-up to your simulations;</li> <li>For large structures that are difficult to optimize, you can try combining  optimizers: use something like <code>FIRE</code> with looser convergence criteria, then use  <code>Rational</code> with tighter convergence criteria to find a stable minima;</li> <li>Avoid using <code>SteepestDescent</code> unless you need it for a specific reason.</li> </ol> <p>The setting block then continues with <code>LatticeOpt</code>, which is disabled by default. This setting allows DFTB+ to change the cell lattice vectors to obtain a fully relaxed  cell, but has no usage for non-periodic calculations. I will go more in depth on this in a later tutorial.</p> <p>The tag <code>MovedAtoms</code> controls which atoms are moved during the simulation, and by  default the entire system is selected. This is useful when constrains are needed for large molecules, or when parts of the molecule should be kept intact while others  need adjustments. </p> <p>The <code>Convergence</code> block is the most important part of the section, as it sets the convergence criteria for the optimization. By default, you can notice that <code>Energy</code>, <code>GradNorm</code>, <code>DispNorm</code>, and <code>DispElem</code> all have huge values assigned; this is  because \"stock\" DFTB+ optimizations only track the maximum absolute gradient element, which has to be smaller than 0.0001 Hartree/Bohr. </p> <p>This is a good moment to introduce units in the equation: DFTB+ uses atomic units by default, but allows the user to use custom units for many properties. Looking at  forces, for example, there are three options available:</p> <ul> <li>Hartree per Bohr: Hartree/Bohr, Ha/Bohr, au</li> <li>Electronvolts per \u00c5ngstr\u00f6m: eV/Angstrom, eV/AA, eV/A</li> <li>Joules per meter: Joule/meter, J/m</li> </ul> <p>It is always a good idea to use the units you are most familiar with instead of manually converting values. To specify the unit of the property, you would attach it in square brackets next to the property, something like:</p> Ha/BohreV/AAJ/m <pre><code>Convergence = {\n    GradElem [Ha/Bohr] = 1.0000000000000000E-004\n}\n</code></pre> <pre><code>Convergence = {\n    GradElem [eV/AA] = 1.0000000000000000E-004\n}\n</code></pre> <pre><code>Convergence = {\n    GradElem [J/Bohr] = 1.0000000000000000E-004\n}\n</code></pre> <p>The same can be done for length, mass, volume, energy, force, time, charge, velocity,  pressure, frequency, electric field strength, dipole moment, and angular units. I  will not list all units here, but if you are curious you should check Appendix C of the DFTB+ manual.</p> <p>Coming back to the convergence criteria, choosing the appropriate thresholds is  crucial to keeping both performance and accuracy high; using loose values can lead to inaccurate results, while tight values lead to longer convergence times. It is always a good idea to get some inspiration from other quantum calculation software:</p>"},{"location":"dftbp/single-point/","title":"Performing single-point calculations in DFTB+","text":"<p>This tutorial explores the settings required to perform static calculations in DFTB+, mainly using extended tight-binding (xTB) methods such as GFN1-xTB and GFN2-xTB. The section starts with an overview of the files necessary to start a simulation, and then goes into all the possible options one can pick as of version 24.1 of DFTB+.</p> <p>The tutorial is based on three sources of information:</p> <ul> <li>The DFTB+ manual (highly recommended to have at hand), which you can find  here</li> <li>The official DFTB+ recipes</li> <li>My three-month experience with the software</li> </ul>"},{"location":"dftbp/single-point/#folder-structure","title":"Folder structure","text":"<p>Unlike other molecular modeling software, DFTB+ requires only one file to set up a  basic calculation: the input file, always called dftb_in.hsd. The complete  specifications of the Human-friendly Structured Data (.hsd) format are presented in  Appendix B in the DFTB+ manual, but they can be summarized as:</p> Human-friendly Structured Data format<pre><code>Property = value  # Everything after a hashtag is a comment\n\nProperty = value { subvalue1 subvalue2 }\n\nSettingBlock = {\n    Property1 [units] = value\n    Property2 = value\n    SubSettingBlock = Value {\n        ...\n    }\n}\n\nSettingBlock = {\n    &lt;&lt;&lt; \"file.txt\"\n}\n</code></pre> file.txt<pre><code>Property = value\n</code></pre> <p>The .hsd format is flexible, as it does not enforce the usage of tabs and new lines.  One could in principle write an entire settings block on one line and DFTB+ would  still be able to read it. Moreover, uppercase and lowercase letters are treated the  same, so the exact case used does not affect the behavior of the software. Finally,  it is possible to introduce raw text from external files using <code>&lt;&lt;&lt;</code>, which makes the .hsd format modular.</p> <p>To start the simulation, one only needs to call <code>dftb+</code> in the local folder and the software automatically parses the dftb_in.hsd file and proceeds with the  calculations. As DFTB+ prints the results on the screen, a good idea is to redirect the output to a file which can be analyzed later, which can be done using the <code>tee</code> program. The recommended complete command is:</p> <pre><code>dftb+ | tee dftb.out\n</code></pre>"},{"location":"dftbp/single-point/#loading-geometries","title":"Loading geometries","text":"<p>As you might expect, a geometry file is needed in order to perform a simulation using  DFTB+. This geometry can either be provided as part of the dftb_in.hsd file, or can be loaded from an external file using the <code>&lt;&lt;&lt;</code> operator mentioned above.  Throughout these tutorials, only the second method will be used as it is more flexible and shortens the DFTB+ input file. Nevertheless, if you insist on having all information in one file, you only have to replace <code>&lt;&lt;&lt; \"name.file\"</code> with the contents  of the geometry file.</p> <p>Depending on the type of calculation that has to be performed (M - molecular,  P - periodic), DFTB+ currently supports 4 different formats for geometries:</p> <ul> <li>Explicit geometry specification (M, P)</li> <li>.gen files (M, P)</li> <li>.xyz files (M)</li> <li>POSCAR and CONTCAR files (P)</li> </ul> <p>Information on how to interact with each of these formats can be found in Section 2.2  of the DFTB+ manual. In this tutorial we will only be focusing on the .gen file  format, which is the intended file format to be used with DFTB+. </p> <p>The .gen file is a simple text-based format used to define the atomic structure of a  system for simulations. The complete specification of the format are explained in Appendix D of the DFTB+ manual. In short, it contains information about the number of  atoms, atomic species, and their coordinates. Inspired from the .xyz format, the  first line of the file contains the number of atoms, together with a flag. Currently,  there are 4 flags available:</p> <ul> <li>C (from cluster) is used for non-periodic calculations</li> <li>S (from supercell) is used for periodic calculations with Cartesian coordinates</li> <li>F (from fractional) is used for periodic calculations with fractional coordinates</li> <li>H (from helical) is used for one-dimensional periodic helical cells</li> </ul> <p>The second line contains a list of atomic species (element symbols), separated by  spaces. Following that, the data for each atom is provided, which includes the atom  index (starting from 1), atomic species index (referring to the order in the second  line), and X, Y, and Z coordinates (in \u00c5ngstr\u00f6ms if Cartesian). Finally, if the  structure is periodic, the last 4 lines should provide the origin and each lattice vector. An example file for a simple water molecule is provided below:</p> H2O.gen<pre><code>3 C\nO H\n1 1  0.00000000000E+00 -0.10000000000E+01  0.00000000000E+00\n2 2  0.00000000000E+00  0.00000000000E+00  0.78306400000E+00\n3 2  0.00000000000E+00  0.00000000000E+00 -0.78306400000E+00\n</code></pre> <p>Another example is a periodic structure written in Cartesian coordinates, in this case a gallium arsenide crystal:</p> GaAs.gen<pre><code>2 S\nGa As\n1 1  0.000000 0.000000 0.000000\n2 2  1.356773 1.356773 1.356773\n0.000000 0.000000 0.000000\n2.713546 2.713546 0.\n0.       2.713546 2.713546\n2.713546 0.       2.713546\n</code></pre> <p>In case you prefer it in fractional coordinates, here is another example:</p> GaAs.gen<pre><code>2 F\nGa As\n1 1  0.0  0.0  0.0\n2 2  0.25 0.25 0.25\n0.000000 0.000000 0.000000\n2.713546 2.713546 0.\n0.       2.713546 2.713546\n2.713546 0.       2.713546\n</code></pre>"},{"location":"dftbp/single-point/#setting-up-an-extended-tight-binding-calculation","title":"Setting up an extended tight-binding calculation","text":"<p>Now that you are familiar with the input file structure and the geometry format used, it's time to perform your first calculation using DFTB+. For now, we will use a  non-periodic structure, on which we will perform a static calculation. A good  starting point is a water molecule, for which the geometry was already provided above. Save that to a file called and H2O.gen and then create the input file  dftb_in.hsd containing the lines below:</p> dftb_in.hsd<pre><code>Geometry = GenFormat {\n    &lt;&lt;&lt; \"H2O.gen\"\n}\n\nDriver = { }\n\nHamiltonian = xTB {\n    Method = \"GFN1-xTB\"\n}\n</code></pre> <p>That is all you need for a single-point calculation! The <code>Geometry</code> tag specifies the geometry that you work with and takes as argument the reader needed to parse the file. You could use xyzFormat or VaspFormat for the other file types. The <code>Driver</code> tag is  reserved for the update method you used: you can perform optimizations or molecular  dynamics runs, both of which require updated positions. Leaving it empty tells DFTB+  that the geometry will not be update, so you end up having a single-point calculation.  The <code>Hamiltonian</code> tag takes as argument the type of Hamiltonian used in the  simulations, which can either be <code>DFTB</code> or <code>xTB</code>. Finally, we specify the method used using the <code>Method</code> tag, which is set to <code>GFN1-xTB</code>. </p> <p>All is left to do is running the simulation using the method shown above. Congratulations! You performed your first DFTB+ simulation. The calculation resulted in a few files being created in the local directory, which should now look like this:</p> <pre><code>band.out  charges.bin  detailed.out  dftb_in.hsd  dftb.out  dftb_pin.hsd  H2O.gen\n</code></pre>"},{"location":"dftbp/single-point/#inspecting-the-results","title":"Inspecting the results","text":"<p>The final part of this tutorial is inspecting the results of the simulation, which are split between multiple files. More information about each file can be found in  Chapter 3 of the DFTB+ manual. Moreover, a review of the files can also be found on DFTB+ Recipes.</p>"},{"location":"dftbp/single-point/#bandout","title":"band.out","text":"<p>The band.out file contains information about the energy levels in the system. The first line shows the k-point number (in this case 1), the spin considered (1 for up, 2 for down), and the weight at that specific k-point (also 1 here). After this, the index, energy, and occupation of each orbital is provided. For a periodic calculation, this block would be repeated for each k-point used. Similarly, for a  spin unrestricted calculation the block would be repeated two times, once for each spin. The information in this file is key to producing the band diagram of a  structure, something which will be explained in a later tutorial.</p> band.out<pre><code>KPT            1  SPIN            1  KWEIGHT    1.0000000000000000\n    1   -19.732  2.00000\n    2   -15.422  2.00000\n    3   -15.136  2.00000\n    4   -13.302  2.00000\n    5    -6.579  0.00000\n    6    -4.194  0.00000\n    7    -1.895  0.00000\n    8     0.513  0.00000\n</code></pre> <p>In the case at hand, there are 8 molecular orbitals (2 from each hydrogen and 4 from  the oxygen), 4 of which are fully occupied. Looking at the energy difference between  the highest occupied molecular orbital (HOMO) and lowest unoccupied molecular orbital  (LUMO), we get that the HOMO-LUMO gap of water is around 6.7 eV, which is close to  the 6.3 eV gap reported by Stephanie ten Brinck et al. using ZORA-BLYP-D3(BJ)/TZ2P. However, as in our case the molecule was not optimized,  it is highly likely that the actual HOMO-LUMO gap is even higher.</p>"},{"location":"dftbp/single-point/#chargesbin","title":"charges.bin","text":"<p>Unfortunately, the charges.bin file is in binary format, which means it is not human-readable. DFTB+ offers the option to save in text format, but that is not enabled by default. A complete overview of the file is provided in Appendix L of the DFTB+ manual, but what is important to know is that this file is needed to restart  calculations, as it stores the previously computed charges.</p>"},{"location":"dftbp/single-point/#detailedout","title":"detailed.out","text":"<p>The detailed.out file contains the most detailed information about your system: the total charge, the partial charges, the shell occupations, energetic properties,  the dipole moment, and many other properties that are not enabled by default. In terms of content importance, it is on the same level as the dftb.out file, meaning that you will most likely have to interact with it relatively often. The only reason it is not higher on the list is because the information in detailed.out only cover the properties of the last system analyzed, so it does not track the changes in electronic structure between different SCC cycles or geometries. </p> <p>Since the file dumps a lot of information on you, it is important to know what you  can find in there. The file starts off with some information about the electronic  filling method used and the current geometry step, and then provides information about the current state:</p> <pre><code>********************************************************************************\n iSCC Total electronic   Diff electronic      SCC error\n    9   -0.56656703E+01    0.60625955E-07    0.28145263E-05\n********************************************************************************\n</code></pre> <p>The text above mentions that on the 9th cycle of the self convergent charge (SCC) procedure the total electronic energy was -5.67 Ha, which was only 6E-8 Ha different compared to the 8th cycle. However, DFTB calculations do not use traditional self convergent field (SCF) methods, and as such the energy difference is not  important during the calculation. The important metric is the SCC error, which tells you the difference in partial charges between the two cycles. Unconverged  charges will result in poor results, so this tolerance has to be determined carefully.</p> <p>The file then continues with information about the total charge inside the system, and the atomic partial charges, which are based on Mulliken analysis. The Mulliken  analysis is enabled by default for all calculations, but can be manually turned off if it is not required.</p> <pre><code>Total charge:    -0.00000000      \n\nAtomic gross charges (e)\nAtom           Charge\n   1      -0.59242485\n   2       0.29621242\n   3       0.29621242\n</code></pre> <p>The Mulliken analysis section continues with more in-depth information about the electronic occupation, providing 3 levels of details. The first level describes the number of electrons in the system and the electronic occupation per atom. A quick look at the number of electrons may already raise question marks: why are there only 8 electrons in the system when in actuality there should be 10? In the case at hand, GFN1-xTB uses a reduced basis set where core electrons are ignored. This means that oxygen only has the shells 2s and 2p, losing two electrons in the process. As such, you can think that on atom 1 the population is actually 8.59, not 6.59, thus increasing the total number of electrons to 10.</p> <pre><code>Nr. of electrons (up):      8.00000000\nAtom populations (up)\n Atom       Population\n    1       6.59242485\n    2       0.70378758\n    3       0.70378758\n</code></pre> <p>The second level describes the occupation per l-shell, which gives two entries per atom (oxygen has 2s and 2p, hydrogen has 1s and 2s). The third level provides the population per orbital, which cannot exceed 2.0 due to Pauli's exclusion principle.</p> <pre><code>l-shell populations (up)\n Atom Sh.   l       Population\n    1   1   0       1.84212929\n    1   2   1       4.75029555\n    2   1   0       0.66937366\n    2   2   0       0.03441392\n    3   1   0       0.66937366\n    3   2   0       0.03441392\n\nOrbital populations (up)\n Atom Sh.   l   m       Population  Label\n    1   1   0   0       1.84212929  s\n    1   2   1  -1       1.32398491  p_y\n    1   2   1   0       1.42631065  p_z\n    1   2   1   1       2.00000000  p_x\n    2   1   0   0       0.66937366  s\n    2   2   0   0       0.03441392  s2\n    3   1   0   0       0.66937366  s\n    3   2   0   0       0.03441392  s2\n</code></pre> <p>Followed by the Mulliken analysis, the file contains information about the energy inside the system, such as the Fermi level, thermal smearing, total energy, and so on. In general, the Mermin free energy is recommended as a reliable metric for the energy inside the system, as it also accounts for electronic temperature.</p> <pre><code>Fermi level:                        -0.3653155827 H           -9.9407 eV\nBand energy:                        -4.6740022127 H         -127.1861 eV\nTS:                                  0.0000000000 H            0.0000 eV\nBand free energy (E-TS):            -4.6740022127 H         -127.1861 eV\nExtrapolated E(0K):                 -4.6740022127 H         -127.1861 eV\nInput / Output electrons (q):      8.0000000000      8.0000000000 \n\nEnergy H0:                          -5.7249282333 H         -155.7832 eV\nEnergy SCC:                          0.0592579110 H            1.6125 eV\nTotal Electronic energy:            -5.6656703223 H         -154.1707 eV\nRepulsive energy:                    0.0000000000 H            0.0000 eV\nTotal energy:                       -5.6656703223 H         -154.1707 eV\nExtrapolated to 0:                  -5.6656703223 H         -154.1707 eV\nTotal Mermin free energy:           -5.6656703223 H         -154.1707 eV\nForce related energy:               -5.6656703223 H         -154.1707 eV\n</code></pre> <p>The file closes off with information about the dipole moment of the system, which in the case at hand differs from the experimentally determined 1.85 Debye. However, this is most likely due to the settings used for the simulation and the non-optimized geometry used, and will be improved in further tutorials.</p> <pre><code>Dipole moment:   -0.00000000    1.52590939   -0.00000000 au\nDipole moment:   -0.00000000    3.87847511   -0.00000000 Debye\n</code></pre> <p>Enabling more options in the <code>Analysis</code> block can extend this file to contain CM5 charges, forces, stress, and much more. Nevertheless, you are now aware of the default content that can be found here.</p>"},{"location":"dftbp/single-point/#dftbout","title":"dftb.out","text":"<p>DFTB+ Recipes already has an in-depth explanation of the results presented in the dftb.out file, which can be found here. In short, the header shows information about the software and how to cite it. The following section presents the simulation settings such as the SCC tolerance, the  maximum number of SCC iterations, the electronic solver, and so on. These should correspond to the input from dftb_in.hsd. The next part shows the SCC convergence and some energetic properties for the input geometry; this part is short for single-point calculations but can get very lengthy for geometry optimizations and  molecular dynamics. The file ends with some timing benchmarks that might be useful when measuring the speed of the software.</p>"},{"location":"dftbp/single-point/#dftb_pinhsd","title":"dftb_pin.hsd","text":"<p>The final file that was created (actually first chronologically) is the  dftb_pin.hsd file. It is a detailed copy of out dftb_in.hsd file, with the only difference being that the default settings are explicitly mentioned. This has no value from a results point of view, but it provides a great way to check which are all possible settings. It is especially useful since the DFTB+ manual does not explicitly mention some settings for extended tight-binding calculations.</p> <p>That is it for now! Later, we will look into what settings should be changed to obtain accurate results.</p>"},{"location":"dftbp/xtb-hamiltonian/","title":"Using the extended tight-binding Hamiltonian","text":"<p>Now that you know how to perform an extended tight-binding calculation (xTB) on a non-periodic system, it is time to go more in-depth into the settings used for that calculation. After all, the results produced by the calculation should be accurate and reliable. Also, using the correct settings for the xTB Hamiltonian will play a crucial part during geometry optimizations, as this can improve convergence speed and results accuracy.</p> <p>The best place to start is by having a look at the Hamiltonian block from the dftb_pin.hsd file generated during our previous simulation. That way, all  possible settings are visible. Fore more details on each entry you can check Chapter 2.4 from the DFTB+ manual.</p> <p>To make the settings block more clear, the keys can be shuffled to create more consistent blocks, which will be explained below.</p> UnorderedOrdered <pre><code>Hamiltonian = xTB {\n  Method = \"GFN1-xTB\"\n  ShellResolvedSCC = Yes\n  SCC = Yes\n  ReadInitialCharges = No\n  InitialCharges = {}\n  SCCTolerance = 1.0000000000000001E-005\n  ConvergentSCCOnly = Yes\n  SpinPolarisation = {}\n  ElectricField = {}\n  Solver = RelativelyRobust {}\n  Charge = 0.0000000000000000\n  MaxSCCIterations = 100\n  Dispersion = {}\n  Solvation = {}\n  Electrostatics = GammaFunctional {}\n  Differentiation = FiniteDiff {\n    Delta = 1.2207031250000000E-004\n  }\n  ForceEvaluation = \"Traditional\"\n  Mixer = Broyden {\n    MixingParameter = 0.20000000000000001\n    InverseJacobiWeight = 1.0000000000000000E-002\n    MinimalWeight = 1.0000000000000000\n    MaximalWeight = 100000.00000000000\n    WeightFactor = 1.0000000000000000E-002\n  }\n  Filling = Fermi {\n    Temperature = 9.5004460357391702E-004\n  }\n}\n</code></pre> <pre><code>Hamiltonian = xTB {\n  Method = \"GFN1-xTB\"\n  SCC = Yes\n  SCCTolerance = 1.0000000000000001E-005\n  MaxSCCIterations = 100\n  ShellResolvedSCC = Yes\n  ConvergentSCCOnly = Yes\n  Solver = RelativelyRobust {}\n  Mixer = Broyden {\n    MixingParameter = 0.20000000000000001\n    InverseJacobiWeight = 1.0000000000000000E-002\n    MinimalWeight = 1.0000000000000000\n    MaximalWeight = 100000.00000000000\n    WeightFactor = 1.0000000000000000E-002\n  }\n  Filling = Fermi {\n    Temperature = 9.5004460357391702E-004\n  }\n  Charge = 0.0000000000000000\n  InitialCharges = {}\n  ReadInitialCharges = No\n  SpinPolarisation = {}\n  ElectricField = {}\n  Solvation = {}\n  Dispersion = {}\n  Electrostatics = GammaFunctional {}\n  ForceEvaluation = \"Traditional\"\n  Differentiation = FiniteDiff {\n    Delta = 1.2207031250000000E-004\n  }\n}\n</code></pre>"},{"location":"dftbp/xtb-hamiltonian/#extended-tight-binding-models","title":"Extended tight-binding models","text":"<pre><code>Method = \"GFN1-xTB\"\n</code></pre> <p>The first tag, <code>Method</code>, is used to specify the extended tight-binding method used  for the calculations. Currently, DFTB+ supports three models:</p> <ul> <li>GFN1-xTB</li> <li>IPEA-xTB</li> <li>GFN2-xTB</li> </ul> <p>Much like DFT functionals, which one is best depends on the system studied and on the chemical species involved. GFN1-xTB is the first extended tight-binding model  proposed by Grimme et al. and covers parameters for all atomic species with Z \u2264 86. IPEA-xTB is a reparameterization of GFN1-xTB aimed at predicting better ionization potentials. To do so, it expands the basis set of some elements, while keeping most identical to GFN1-xTB. GFN2-xTB is the newest model available, featuring better descriptions for halogens and hydrogen, while also using D4 dispersion corrections as opposed to the D3 corrections used in GFN1-xTB and IPEA-xTB. The advantages of using  GFN2-xTB over GFN1-xTB depend on the system, but it is generally observed that GFN2-xTB has more convergence problems for bad geometries compared to its predecessor. The table below contains information about the basis sets used for each atomic  species:</p> n Element GFN1-xTB IPEA-xTB GFN2-xTB 1 H 1s, 2s 1s, 2s 1s He 1s 1s 1s, 2p 2 Li, Be 2s, 2p 2s, 2p 2s, 2p B-F 2s, 2p 2s, 2p, 3s 2s, 2p Ne 2s, 2p, 3d 2s, 2p, 3d 2s, 2p, 3d 3-5 Group 1 ns, nd ns, nd ns, nd Group 2 ns, np, (n-1)d ns, np, (n-1)d ns, np, (n-1)d Na* 3s, 3p 2s, 2p 3s, 3p Mg* 3s, 3p 2s, 2p 3s, 3p, 3d Groups 3-11 (n-1)d, ns, np (n-1)d, ns, np (n-1)d, ns, np Group 12 ns, np ns, np ns, np Groups 13-17 ns, np, nd ns, np, nd ns, np, nd Noble gases ns, np, nd ns, np, nd ns, np, nd 6 Cs* 5s, 5p 5s, 5p 6s, 6p Ba* 5s, 5p, 4d 5s, 5p, 4d 6s, 6p, 5d Lanthanides 5d, 6s, 6p 5d, 6s, 6p 5d, 6s, 6p Groups 3-11 5d, 6s, 6p 5d, 6s, 6p 5d, 6s, 6p Hg 6s, 6p 6s, 6p 6s, 6p Tl-Bi 6s, 6p 6s, 6p 6s, 6p Po 6s, 6p, 5d 6s, 6p, 5d 6s, 6p At, Rn 6s, 6p, 5d 6s, 6p, 5d 6s, 6p, 5d <p>The elements that have an asterisk use incorrect basis sets in some of the three  models. These are known bugs that were part of the original parameterizations and  thus require significant changes to the models to correct. As such, they will remain unchanged.</p>"},{"location":"dftbp/xtb-hamiltonian/#self-convergent-charges-scc","title":"Self-convergent charges (SCC)","text":"<p>The most important block in the <code>Hemiltonian</code> block is the SCC part, which directly impacts the performance and accuracy of the calculations.</p> <pre><code>SCC = Yes\nSCCTolerance = 1.0000000000000001E-005\nMaxSCCIterations = 100\nShellResolvedSCC = Yes\nConvergentSCCOnly = Yes\nSolver = RelativelyRobust {}\nMixer = Broyden {\n  MixingParameter = 0.20000000000000001\n  InverseJacobiWeight = 1.0000000000000000E-002\n  MinimalWeight = 1.0000000000000000\n  MaximalWeight = 100000.00000000000\n  WeightFactor = 1.0000000000000000E-002\n}\n</code></pre> <p>The first tag, <code>SCC</code>, enables the self-convergent charge procedure during the calculations. Without it, the calculation would use the charge distribution of neutral atoms, which for most systems are not representative. This setting is enabled by  default and should only be disabled if you know the neutral atoms provide a decent description. If enabled, the SCC procedure has two stop conditions:</p> <ul> <li>When the change in charges from cycle to cycle is less than the <code>SCCTolerance</code>;</li> <li>When <code>MaxSCCIterations</code> cycles have been performed.</li> </ul> <p>Next, the tag <code>ShellResolvedSCC</code> determines if all distinct Hubbard U values for the  different atomic angular momenta shells are used. However, this does not seem to have an impact on xTB calculations. The tag <code>ConvergentSCCOnly</code> indicates that forces  and other properties are only computed after the SCC procedure converges, not after each cycle.</p> <p>The last two tags in this section, <code>Solver</code> and <code>Mixer</code>, affect the charge calculation procedure. <code>Solver</code> represents the eigensolver used by DFTB+, which is set to <code>RelativelyRobust</code> by default. Alternatives to this are <code>DivideAndConqer</code> (which  requires twice the memory of the other solvers) and <code>QR</code> (which is based on QR  decomposition). Depending on how the code is compiled, more solvers can be available, such as <code>MAGAM</code> (GPU solver), <code>ELPA</code> (efficient and GPU), <code>OMM</code>, <code>PEXSI</code>, or <code>NTPoly</code>. These have to be added manually at compile-time and have their own advantages and  disadvantages, which should be assessed before usage. </p> <p>On the other hand, <code>Mixer</code> determines that way past solutions from the SCC procedure are \"mixed\" to create a new solution. You may be tempted to think that during the  self-convergence procedure, the charges (or electron density for SCF) computed for one cycle are reused as the starting point of the next cycle. While this can be  accomplished by using the <code>Simple</code> mixer and setting the <code>MixingParameter</code> to 1.0,  most quantum calculation software use complex methods to determine the best starting point for the next cycle. Both DFTB+ and VASP use <code>Broyden</code> mixing by default. Alternatives to this, which require less memory, are <code>Anderson</code> and <code>DIIS</code>. I never used them myself, but it can be a good idea to try them as well to see if it improves convergence and performance.</p>"},{"location":"dftbp/xtb-hamiltonian/#electron-filling-and-smearing","title":"Electron filling and smearing","text":"<p>The <code>Filing</code> block specifies the partial occupation method and electron smearing  used in the calculations. Currently, two methods are available: <code>Fermi</code> and  <code>MethfesselPaxton</code>. Both methods take as argument <code>Temperature</code>, which controls the smearing in the system much like <code>SIGMA</code> does in VASP, with the difference that  DFTB+ uses Hartree as default units. By default, DFTB+ uses a smearing of 300 K, which can be considered low enough for some applications. Nevertheless, according to Basiuk et al., if HOMO-LUMO gaps or other electronic properties are of interest, the smearing can be lowered to 30 K  for more accurate results.</p> DFTB+ defaultVASP default <pre><code>Filling = Fermi {\n  Temperature = 9.5004460357391702E-004\n}\n</code></pre> <pre><code>Filling = MethfesselPaxton {\n  Order = 1\n  Temperature = 7.3498586E-003 \n}\n</code></pre> <p>Which of the two fractional occupation methods produces the best results depends on the system studied. DFTB+ defaults to <code>Fermi</code> filling with 300 K smearing, while  VASP defaults to 1st order <code>MethfesselPaxton</code> filling with 0.2 eV (2321 K) smearing. Nevertheless, the latter can be inaccurate for insulators due to unphysical partial occupancies. </p>"},{"location":"dftbp/xtb-hamiltonian/#system-charges","title":"System charges","text":"<p>This part of the input controls the charges inside the system. The <code>Charge</code> property sets the system charge, which is important when ionic systems are (e.g. acetate,  chloride, etc.). For neutral systems, it should be left unchanged. For ionic system, this should be paired with the following tag, <code>InitialCharges</code>, which assigns the correct charges to the respective atoms.</p> <pre><code>Charge = 0.0000000000000000\nInitialCharges = {}\nReadInitialCharges = No\n</code></pre> <p>The following tag, <code>ReadInitialCharges</code>, allows for previously computed results to be read, which provides the basis of the restart system in DFTB+. As mentioned  previously, simulations create a charges.bin file that stores information about the charges computed during the simulation. Loading these charges at start-time would result in the simulation continuing from those charges, which is effectively a restart.</p>"},{"location":"dftbp/xtb-hamiltonian/#spin-polarized-calculations","title":"Spin-polarized calculations","text":"<p>While this will be explore in depth in another tutorial, the <code>SpinPolarisation</code> tag enables spin-polarised calculations. By default no value is assigned to it, forcing DFTB+ to ignore spin polarisation. By changing it to <code>Colinear</code> or <code>NonColinear</code>,  the user can introduce polarisation in the system, which might be necessary to  accurately model some species (e.g. manganese). </p> <pre><code>SpinPolarisation = {}\n</code></pre>"},{"location":"dftbp/xtb-hamiltonian/#implicit-effects","title":"Implicit effects","text":"<p>As implicit effects, one can introduce an electric field or a solvent in the  simulation, altering the behavior of the system. For zwitterionic systems the introduction of solvation is recommended as it improves the convergence of the SCC cycle. I am not currently interested in simulations with either properties, so  unfortunately I cannot provide more information than what is already stated in the  DFTB+ manual.</p> <pre><code>ElectricField = {}\nSolvation = {}\n</code></pre>"},{"location":"dftbp/xtb-hamiltonian/#hamiltonian-modifications","title":"Hamiltonian modifications","text":"<p>This part of the settings provides the ability to alter the Hamiltonian used in extended tight-binding, but in practice has little utility. While not specifically stated anywhere, the default dispersion schemes used in GFN1-xTB, IPEA-xTB, and  GFN2-xTB are already part of the base parameterization, and thus does not require manual additions using the <code>Dispersion</code> tag. Meanwhile, the <code>Electrostatics</code> tag should only be changed from <code>GammaFunctional</code> to <code>Poisson</code> during transport calculations.</p> <pre><code>Dispersion = {}\nElectrostatics = GammaFunctional {}\n</code></pre>"},{"location":"dftbp/xtb-hamiltonian/#force-calculation","title":"Force calculation","text":"<p>The last part covers how the forces are being calculated during the simulation.  <code>ForceEvaluation</code> can be performed in three ways: <code>traditional</code>, <code>dynamics</code>, and  <code>dynamicsT0</code>. The first one is the default version used to calculate forces in DFTB,  while the other two are meant to be used for non-converged charges. In each case,  the differentiation can be performed using either finite difference (<code>FiniteDiff</code>),  or using <code>Richardson</code> extrapolation, which is the most accurate method to determine  forces.</p> <pre><code>ForceEvaluation = \"Traditional\"\nDifferentiation = FiniteDiff {\n  Delta = 1.2207031250000000E-004\n}\n</code></pre>"}]}